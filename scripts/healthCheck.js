#!/usr/bin/env node

/**
 * –°–∫—Ä–∏–ø—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã ESM –±–æ—Ç–∞
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã, –º–æ–¥–µ–ª–∏, –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
 */

require('dotenv').config();
const mongoose = require('mongoose');
const User = require('../models/User');
const Response = require('../models/Response');
const TrainingProgress = require('../models/TrainingProgress');
const config = require('../config/hurlburt');
const aiValidator = require('../services/ai-validator-service');
const goldenStandard = require('../validators/goldenStandard');
const MomentValidator = require('../validators/momentValidator');
const momentValidator = new MomentValidator();
const { metrics, getMetrics } = require('../utils/metrics');

class HealthChecker {
  constructor() {
    this.results = {
      overall: 'healthy',
      timestamp: new Date(),
      checks: {},
      warnings: [],
      errors: [],
      recommendations: []
    };
  }

  /**
   * –ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
   */
  async runHealthCheck() {
    console.log('üè• ESM Bot Health Check Started...\n');

    try {
      // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
      await this.checkDatabase();

      // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–¥–µ–ª–µ–π –¥–∞–Ω–Ω—ã—Ö
      await this.checkModels();

      // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤
      await this.checkValidators();

      // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ AI —Å–µ—Ä–≤–∏—Å–æ–≤
      await this.checkAIServices();

      // 5. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
      await this.checkConfiguration();

      // 6. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
      await this.checkPerformance();

      // 7. –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ—Ç—Ä–∏–∫
      await this.checkMetrics();

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–±—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      this.determineOverallHealth();

      // –í—ã–≤–æ–¥–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
      this.printResults();

      return this.results;
    } catch (error) {
      this.results.overall = 'critical';
      this.results.errors.push(`Health check failed: ${error.message}`);
      console.error('‚ùå Health check failed:', error);
      return this.results;
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
   */
  async checkDatabase() {
    console.log('üìä Checking database connection...');
    
    try {
      if (mongoose.connection.readyState !== 1) {
        await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/mse-bot');
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–æ–∂–µ–º –≤—ã–ø–æ–ª–Ω—è—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏
      const userCount = await User.countDocuments();
      const responseCount = await Response.countDocuments();

      this.results.checks.database = {
        status: 'healthy',
        connection: 'connected',
        userCount,
        responseCount,
        responseTime: await this.measureDatabaseResponseTime()
      };

      console.log(`‚úÖ Database: ${userCount} users, ${responseCount} responses`);
    } catch (error) {
      this.results.checks.database = {
        status: 'error',
        error: error.message
      };
      this.results.errors.push(`Database connection failed: ${error.message}`);
      console.log('‚ùå Database connection failed');
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–¥–µ–ª–µ–π –¥–∞–Ω–Ω—ã—Ö
   */
  async checkModels() {
    console.log('üìã Checking data models...');

    try {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ö–µ–º—ã –º–æ–¥–µ–ª–µ–π
      const userSchema = User.schema;
      const responseSchema = Response.schema;
      const trainingSchema = TrainingProgress.schema;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–ª—é—á–µ–≤—ã—Ö –ø–æ–ª–µ–π
      const userFields = Object.keys(userSchema.paths);
      const responseFields = Object.keys(responseSchema.paths);
      const trainingFields = Object.keys(trainingSchema.paths);

      const requiredUserFields = [
        'telegramId', 'trainingStartDate', 'currentTrainingDay',
        'averageDataQuality', 'qualityHistory', 'phenomenaFrequencies',
        'commonPatterns', 'preferences', 'achievements'
      ];

      const missingUserFields = requiredUserFields.filter(field => !userFields.includes(field));

      if (missingUserFields.length > 0) {
        this.results.warnings.push(`Missing user fields: ${missingUserFields.join(', ')}`);
        this.results.recommendations.push('Run user migration: node migrations/addGoldenStandardFields.js');
      }

      this.results.checks.models = {
        status: missingUserFields.length === 0 ? 'healthy' : 'warning',
        userFields: userFields.length,
        responseFields: responseFields.length,
        trainingFields: trainingFields.length,
        missingUserFields
      };

      console.log(`‚úÖ Models: User(${userFields.length}), Response(${responseFields.length}), Training(${trainingFields.length})`);
    } catch (error) {
      this.results.checks.models = {
        status: 'error',
        error: error.message
      };
      this.results.errors.push(`Model check failed: ${error.message}`);
      console.log('‚ùå Model check failed');
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤
   */
  async checkValidators() {
    console.log('üîç Checking validators...');

    try {
      // –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
      const testResponses = [
        '–°–º–æ—Ç—Ä–µ–ª –Ω–∞ –∫—É—Ä—Å–æ—Ä –ø–æ—Å–ª–µ —Å–ª–æ–≤–∞ "–ø—Ä–æ–µ–∫—Ç". –í –∂–∏–≤–æ—Ç–µ –ª—ë–≥–∫–æ–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ.',
        '–û–±—ã—á–Ω–æ —è –≤—Å–µ–≥–¥–∞ —Ä–∞–±–æ—Ç–∞—é —Ö–æ—Ä–æ—à–æ',
        '–ß–∏—Ç–∞–ª –∫–Ω–∏–≥—É, –ø—Ä–æ–≥–æ–≤–∞—Ä–∏–≤–∞—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–º –≥–æ–ª–æ—Å–æ–º –∫–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ'
      ];

      const validatorResults = {
        momentValidator: [],
        goldenStandard: []
      };

      // –¢–µ—Å—Ç–∏—Ä—É–µ–º momentValidator
      for (const response of testResponses) {
        const result = momentValidator.validate(response, 'pristine', { trainingDay: 1 });
        validatorResults.momentValidator.push({
          text: response.substring(0, 30) + '...',
          score: result.score,
          valid: result.valid
        });
      }

      // –¢–µ—Å—Ç–∏—Ä—É–µ–º goldenStandard
      for (const response of testResponses) {
        const baseValidation = momentValidator.validate(response);
        const enhanced = goldenStandard.enhance(baseValidation, response, { trainingDay: 1 });
        validatorResults.goldenStandard.push({
          text: response.substring(0, 30) + '...',
          score: enhanced.score,
          quality: enhanced.quality
        });
      }

      this.results.checks.validators = {
        status: 'healthy',
        momentValidator: validatorResults.momentValidator,
        goldenStandard: validatorResults.goldenStandard,
        averageBaseScore: validatorResults.momentValidator.reduce((acc, r) => acc + r.score, 0) / testResponses.length,
        averageEnhancedScore: validatorResults.goldenStandard.reduce((acc, r) => acc + r.score, 0) / testResponses.length
      };

      console.log('‚úÖ Validators: Working correctly');
    } catch (error) {
      this.results.checks.validators = {
        status: 'error',
        error: error.message
      };
      this.results.errors.push(`Validator check failed: ${error.message}`);
      console.log('‚ùå Validator check failed');
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ AI —Å–µ—Ä–≤–∏—Å–æ–≤
   */
  async checkAIServices() {
    console.log('ü§ñ Checking AI services...');

    try {
      const aiStats = aiValidator.getUsageStats();
      const hasApiKeys = !!(process.env.OPENAI_API_KEY || process.env.ANTHROPIC_API_KEY);

      let aiStatus = 'healthy';
      if (!hasApiKeys) {
        aiStatus = 'warning';
        this.results.warnings.push('No AI API keys configured - using local validation only');
      }

      // –ë—ã—Å—Ç—Ä—ã–π —Ç–µ—Å—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏
      let validationTest = null;
      try {
        validationTest = await aiValidator.validate(
          '–¢–µ—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏—Å—Ç–µ–º—ã',
          { userId: 'health-check', trainingDay: 1, timeout: 30000 }
        );
      } catch (error) {
        this.results.warnings.push(`AI validation test failed: ${error.message}`);
      }

      this.results.checks.aiServices = {
        status: aiStatus,
        provider: aiStats.provider,
        isConfigured: aiStats.isConfigured,
        cacheSize: aiStats.cacheSize,
        rateLimitEntries: aiStats.rateLimitEntries,
        hasApiKeys,
        validationTest: validationTest ? 'passed' : 'failed'
      };

      console.log(`‚úÖ AI Services: ${aiStats.provider} (${aiStats.isConfigured ? 'configured' : 'local only'})`);
    } catch (error) {
      this.results.checks.aiServices = {
        status: 'error',
        error: error.message
      };
      this.results.errors.push(`AI services check failed: ${error.message}`);
      console.log('‚ùå AI services check failed');
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
   */
  async checkConfiguration() {
    console.log('‚öôÔ∏è Checking configuration...');

    try {
      const configCheck = {
        hasHurlburtConfig: !!config,
        hasValidationConfig: !!(config.validation),
        hasAIConfig: !!(config.ai),
        hasPhenomenaConfig: !!(config.phenomena),
        hasTrainingConfig: !!(config.training),
        validationEnabled: config.validation?.useGoldenStandard || false,
        aiEnabled: config.ai?.enableSmartValidation || false
      };

      let configStatus = 'healthy';
      if (!configCheck.hasValidationConfig) {
        configStatus = 'warning';
        this.results.warnings.push('Validation configuration missing');
      }

      this.results.checks.configuration = {
        status: configStatus,
        ...configCheck
      };

      console.log(`‚úÖ Configuration: ${Object.values(configCheck).filter(Boolean).length}/${Object.keys(configCheck).length} checks passed`);
    } catch (error) {
      this.results.checks.configuration = {
        status: 'error',
        error: error.message
      };
      this.results.errors.push(`Configuration check failed: ${error.message}`);
      console.log('‚ùå Configuration check failed');
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   */
  async checkPerformance() {
    console.log('‚ö° Checking performance...');

    try {
      const startTime = Date.now();
      
      // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏–∏
      const validationStartTime = Date.now();
      const testValidation = momentValidator.validate(
        '–°–º–æ—Ç—Ä–µ–ª –Ω–∞ —ç–∫—Ä–∞–Ω, –∫—É—Ä—Å–æ—Ä –º–∏–≥–∞–ª –ø–æ—Å–ª–µ —Å–ª–æ–≤–∞ "—Ç–µ—Å—Ç"', 
        'pristine'
      );
      const validationTime = Date.now() - validationStartTime;

      // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ –ë–î
      const dbStartTime = Date.now();
      await User.findOne().limit(1);
      const dbTime = Date.now() - dbStartTime;

      const totalTime = Date.now() - startTime;

      const performanceCheck = {
        validationTime,
        databaseTime: dbTime,
        totalCheckTime: totalTime,
        memoryUsage: process.memoryUsage(),
        uptime: process.uptime()
      };

      let performanceStatus = 'healthy';
      if (validationTime > 1000) {
        performanceStatus = 'warning';
        this.results.warnings.push('Validation is slow (>1s)');
      }
      if (dbTime > 500) {
        performanceStatus = 'warning';
        this.results.warnings.push('Database queries are slow (>500ms)');
      }

      this.results.checks.performance = {
        status: performanceStatus,
        ...performanceCheck
      };

      console.log(`‚úÖ Performance: Validation ${validationTime}ms, DB ${dbTime}ms`);
    } catch (error) {
      this.results.checks.performance = {
        status: 'error',
        error: error.message
      };
      this.results.errors.push(`Performance check failed: ${error.message}`);
      console.log('‚ùå Performance check failed');
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ—Ç—Ä–∏–∫
   */
  async checkMetrics() {
    console.log('üìà Checking metrics...');

    try {
      const currentMetrics = getMetrics();
      
      this.results.checks.metrics = {
        status: 'healthy',
        validationRequests: currentMetrics.validationRequests,
        averageResponseQuality: currentMetrics.computed.averageResponseQuality,
        cacheHitRate: currentMetrics.computed.cacheHitRate,
        trainingCompletions: currentMetrics.trainingCompletions,
        totalResponses: currentMetrics.totalResponses
      };

      console.log(`‚úÖ Metrics: ${currentMetrics.validationRequests} validations, ${currentMetrics.computed.averageResponseQuality} avg quality`);
    } catch (error) {
      this.results.checks.metrics = {
        status: 'error',
        error: error.message
      };
      this.results.errors.push(`Metrics check failed: ${error.message}`);
      console.log('‚ùå Metrics check failed');
    }
  }

  /**
   * –ò–∑–º–µ—Ä–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–∫–ª–∏–∫–∞ –ë–î
   */
  async measureDatabaseResponseTime() {
    const start = Date.now();
    await mongoose.connection.db.admin().ping();
    return Date.now() - start;
  }

  /**
   * –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ–±—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∑–¥–æ—Ä–æ–≤—å—è
   */
  determineOverallHealth() {
    const checks = Object.values(this.results.checks);
    const errorCount = checks.filter(check => check.status === 'error').length;
    const warningCount = checks.filter(check => check.status === 'warning').length;

    if (errorCount > 0) {
      this.results.overall = 'critical';
    } else if (warningCount > 2) {
      this.results.overall = 'degraded';
    } else if (warningCount > 0) {
      this.results.overall = 'warning';
    } else {
      this.results.overall = 'healthy';
    }
  }

  /**
   * –í—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
   */
  printResults() {
    console.log('\n' + '='.repeat(50));
    console.log('üè• HEALTH CHECK RESULTS');
    console.log('='.repeat(50));

    // –û–±—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    const statusEmojis = {
      healthy: '‚úÖ',
      warning: '‚ö†Ô∏è',
      degraded: 'üü°',
      critical: '‚ùå'
    };

    console.log(`\nOverall Status: ${statusEmojis[this.results.overall]} ${this.results.overall.toUpperCase()}\n`);

    // –î–µ—Ç–∞–ª–∏ –ø–æ –∫–∞–∂–¥–æ–º—É –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É
    Object.entries(this.results.checks).forEach(([component, check]) => {
      const emoji = statusEmojis[check.status] || '‚ùì';
      console.log(`${emoji} ${component}: ${check.status}`);
    });

    // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
    if (this.results.warnings.length > 0) {
      console.log('\n‚ö†Ô∏è WARNINGS:');
      this.results.warnings.forEach((warning, i) => {
        console.log(`  ${i + 1}. ${warning}`);
      });
    }

    // –û—à–∏–±–∫–∏
    if (this.results.errors.length > 0) {
      console.log('\n‚ùå ERRORS:');
      this.results.errors.forEach((error, i) => {
        console.log(`  ${i + 1}. ${error}`);
      });
    }

    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
    if (this.results.recommendations.length > 0) {
      console.log('\nüí° RECOMMENDATIONS:');
      this.results.recommendations.forEach((rec, i) => {
        console.log(`  ${i + 1}. ${rec}`);
      });
    }

    console.log('\n' + '='.repeat(50));
  }
}

// –ó–∞–ø—É—Å–∫ –ø—Ä–æ–≤–µ—Ä–∫–∏ –µ—Å–ª–∏ —Ñ–∞–π–ª –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é
if (require.main === module) {
  const checker = new HealthChecker();
  
  checker.runHealthCheck()
    .then(results => {
      const exitCode = results.overall === 'critical' ? 1 : 0;
      process.exit(exitCode);
    })
    .catch(error => {
      console.error('Health check script failed:', error);
      process.exit(1);
    });
}

module.exports = HealthChecker;